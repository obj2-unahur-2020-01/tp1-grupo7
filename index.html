<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>*TP Grupo7*</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<p>
							<h3>Trabajo Práctico Grupal</h3>
						</p>
						<p class="fragment" data-fragment-index="0">Lenguaje a presentar: "GO"</p>
						<p class="fragment" data-fragment-index="1">
							Integrantes:
						</p>
						<p class="fragment" data-fragment-index="2">
							Alberto Leandro Sanchez<br>
							Hereñu Luis Marcelo <br>
							Yesica Belen Ramirez <br>
							Vallés Franco David 
						</p>
					</section>
				</section>					
				<section id="fragments">
					<h2>Qué es GO?</h2>
					<p>Go es un lenguaje de programación...</p>
					<p><span class="fragment">...concurrente</span> <span class="fragment">y</span> <span class="fragment">compilado.</span></p>
						<p><span class= "fragment"> Inspirado en la sintaxis de C, que intenta ser dinámico como Python y con el rendimiento de C o C++.</span></p>
							<p><span class= "fragment"> Otras de sus características principales son que es imperativo, estructurado y orientado a objetos.</span></p>	
				</section>
				<section>
                    <section>
                        <h1> Un poco de historia sobre el lenguaje </h1>
                        <p> GO fue desarrollado por Google y sus diseñadores principales son: </p>
                        <p><span class="fragment"> Robert Griesemer, Rob Pike y Ken Thompson. </span></p>
                    </section>
					<section>
						<p> Go fue diseñado en Google, en el año 2007 para mejorar la productividad de programación de sus desarrolladores. </p>
                        <p><span class="fragment"> en una era de computadoras con procesadores de nucleos múltiples, conectadas a través de una network y bases de código fuente grandes. </span></p>
                        <p><span class="fragment"> Go fue anunciado públicamente en noviembre del 2009, y la versión 1.0 fue lanzada en marzo del 2012. </span></p>
					</section>	
				</section>
				<section>
					<p> Algunos de los motivos principales de los diseñadores para crear el lenguaje fueron: </p>
					<p> 1.-Las características que no les gustaban de C++. </p>
						<p><span class="fragment"> 2.-Corregir las critícas que tenían hacía otros lenguajes que se usaban en Google pero a su vez conservar las características útiles. Por ejemplo: </span></p>
					<section>
						<p> - El tipado estático y la eficiencia del tiempo de ejecución, como el de C++. 
							</p>
							<p><span class="fragment"> - La legibilidad y usabilidad de Python y JavaScript. 
								</span></p>
							<p><span class="fragment"> - Mejor desempeño de networking y multiprocesamiento. 
								</span></p>
					</section>
				</section>
				<section>
					<h2>Asi se ve un programa basico en GO</h2>
					<iframe height="400px" width="100%" src="https://repl.it/@albertosanchez6/LoudAlarmedJavadoc?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
				</section>
				<section>
					<section>
						<h2>Variables</h2>
						<p>Las variables en Go se pueden declarar explicitamente o se puede incializar con un valor y estas no pueden cambiar de tipo en un futuro, para asegurar que cuando una funcion las llame sean del tipo correcto.</p>
					</section>
					<section>
						<p>Para declarar una variable se usa 'var'</p>
						<pre><code>var a string = "initial"</code></pre>
						<br>
						<p>Tambien se puede declarar multiples variables en una linea</p>
						<pre><code>var b, c int = 1, 2</code></pre>
					</section>
					<section>
						<p>Las variables pueden ser declaradas sin inicializarce, estas por default son de valor cero, por ejemplo:</p>
						<pre><code>var a int
var b string
var c float64
var d bool
	</code></pre>
						<p>el output de a seria "0", de b: "" , de c: "0" y de d: false </p>
						
					</section>
					<section>									
						<p>En Go existe la sintaxis ":=" que es una abreviatura para incializar variables. Por ejemplo:</p>
						<pre><code>f := "short"</code></pre>
						<span>es igual a</span>
						<pre><code>var f string = "short"</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Condicionales</h3>
						<p> Las sentencias condicionales en GO nos permiten controlar la ejecución de código en nuestro algoritmo, dependiendo del resultado de la evaluación de la condición que se define en la estructura del condicional.</p>
					</section>
					<section>
						<p> hay diferentes tipos de sentencias condicionales: </p>
						<p> sentencia IF</p>
						<p> sentencia IF-ELSE</p>
						<p> sentencia ELSE IF</p>
						<p> sentencia SWITCH</p>
						<p> sentencia SELECT</p>
					</section>
					<section>
						<h4> Sentencia IF</h4>
						<p>	La sentencia if se utiliza para verificar la veracidad de una expresión, y de ser verdadera se ejecutará el código destinado para cuando la condición se cumpliera</p>
					</section>
					<section>
						<p> Ejemplo: Tenemos una variable “número” definida con valor de entero 5 y tenemos una sentencia IF con la condición a evaluar de que si la variable “número” es menor que 9 diera verdadera, debe ejecutarse la llamada al println de fmt, el cual imprimirá en pantalla “el número es menor a 9”.</p>
						<pre><code>
							var numero int = 5
							if  numero<9{
							fmt.Println(“el numero es menor a 9”)
							}
						</code></pre>
					</section>
					<section>
						<p> Pero esto es limitado, ¿Qué sucede si quiero ejecutar una parte del código cuando no se cumpla la condición?</p>
						<p><span class="fragment"> para ello utilizaremos la sentencia IF-ELSE. </span></p>
					</section>
					<section>
						<h5> Sentencia IF-ELSE</h5>
						<p> Ah la sentencia IF , se le agrega otra rama de ejecución llamada ELSE, cuando la condición establecida en la sentencia IF no se cumpla, se ejecutará el código definido en la rama else.	</p>
						<pre><code>
							var numero int = 5
							if  numero<9{
								fmt.Println(“el numero es menor a 9”)
							}else{
								fmt.Println(“el numero es mayor a 9”)
							}
						</code></pre>
					</section>
					<section>
						<h6> PREGUNTA</h6>
						<p> Qué sucede si queres trabajar con múltiples condiciones en cadena, para que se evalúen de a una?</p>
						<br>
						<p><span class="fragment"> RESPUESTA: ELSE IF. </span></p>
					</section>
					<section>
						<h7>Sentencia ELSE IF</h7>
						<p>La sentencia ELSE IF nos permite encadenar condiciones para que se evalúen en el instante en que la condición anterior dio falsa.</p>
						<pre><code>
							var numero int = 5
							if  numero<9{
								fmt.Println(“el numero es menor a 9”)
							}
							else if numero == 5{
								fmt.Println(“el numero es igual a 5”)
							}
							else{
								fmt.Println(“el numero es mayor a 9”)
							}
						</code></pre>
						<p>	Con esto finaliza las sentencias relacionadas al IF.</p>
					</section>
					<section>
						<h8>Sentencia SWITCH</h8>
						<p>Esta sentencia nos permite evaluar una variable contra una lista de valores conocidos como case (casos en ingles).</p>
						<p> En GO los switch pueden ser de dos tipos</p>
						<p><span class="fragment">
							EXPRESIÓN: Los case contienen expresiones que son comparadas con el valor de la variable a evaluar.
						</span></p>
						<br>
						<p><span class="fragment">
							TIPO: Los case contienen un tipo de dato que es comparado con el tipo de dato de la variable a evaluar.
						</span></p>
					</section>
					<section>
						<h9>Switch de expresiones:</h9>
						<p>Reglas que aplican para este tipo de switch:</p>
						<p> •Si no pasa una expresión, el valor por defecto es true.</p>
						<p>	•No hay límite de case siempre y cuando cada case esté seguido de al menos un valor contra el cual comparar y dos puntos.</p>
						<p>	•Si se usa una expresión constante para un case, debe de ser del mismo tipo que el valor a evaluar, y debe de ser una constante o literal.</p>
					</section>
					<section>
						<p>	•Cuando la variable a evaluar es igual a un case, el código después de los dos puntos (“ : “) se ejecuta. No se utiliza break para terminar el case.</p>
						<p>	•Puede haber un case por default (defecto) para ejecutarse cuando no se cumple ningún case. El case default debe ir al final y no necesita break.</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code>
							func main() {
 							/*variable local de tipo entero*/
 								var hora int = 10

		 					/*Se pasa hora como variable de prueba*/
 								switch hora{
   							/*Si hora coincide con alguna de las literales especificadas*/
   									case 1, 2, 3, 4: fmt.Println("Aún es temprano")
   									case 5, 6, 7: fmt.Println("Está atardeciendo")
   									case 8: fmt.Println("Acaba de oscurecer")
									case 9, 10, 11: fmt.Println("Ya es tarde")
   									default: fmt.Println("Es demasiado tarde")
 								}
							}
						</code></pre>
					</section>
					<section>
						<h10> Switch de tipo</h10>
						<p>	Reglas que aplican para este tipo de switch:</p>
						<p>	•La expresión usada en una sentencia debe de ser una variable o una interface de tipo</p>
						<p>	•No hay límites para la cantidad de case en el switch.</p>
						<p>	•El tipo de dato para un case debe ser el mismo tipo que la variable a evaluar.</p>
						<p>	•Cuando la variable a evaluar es igual a un case, se ejecuta dicho case y los demás no son verificados. No es necesario un break.</p>
					</section>
					<section>
						<p> •Puede haber un case default, para ejecutarse cuando no se cumple ningún case. el case default debe ir al final y no utiliza break</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code>
							func main() {
 							/*variable interface sin tipo asignado*/
 								var x interface{}
 								switch x.(type){ /*Retorna el tipo de x*/
							/*Casos*/
   									case nil: fmt.Println("Es una variable tipo nil")
   									case int: fmt.Println("Es una variable tipo int")
   									case float64: fmt.Println("Es una variable tipo float64")
   									case int64: fmt.Println("Es una variable tipo int64")
   									default: fmt.Println("No es ninguno de los tipos anteriores")
 								}
							}
						</code></pre>
					</section>
					<section>
						<h11>Sentencia SELECT CASE</h11>
						<p>La sentencia select case, permite ejecutar una de entre varias acciones en función del valor de una expresión.</p>
					</section>
					<section>
						<p>	como funciona?</p>
						<p>	1.Se evalúa la expresión, dando como resultado un número.</p>
						<p> 2.Luego, se recorren los case, dentro de la estructura buscando que el número coincida con uno de los valores.</p>
						<p> 3.Es necesario que coincidan todos sus valores.</p>

					</section>
					<section>
						<p> 4.Cuando se encuentra la primera coincidencia, se ejecuta el bloque de sentencias correspondiente y se sale de la estructura select case.</p>
						<p> 5.Si no se encuentra ninguna coincidencia con ningún valor, se ejecuta el bloque de sentencias de la selección case else.</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code>
							Select (Expresión)
      							Case Valor1
         							(Bloque de sentencias 1)
      							Case Valor2
         							(Bloque de sentencias 2)
      							Case Valor n
         							(Bloque de sentencias n)
      							Case Else
         							(Bloque de sentencias "Else")
   								End Select
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Clases/Estructuras</h3>
					</section>
					<section>
						<p>
							En <b> GO</b> no existen las clases como tal, en este lenguaje se pueden hacer <b>ESTRUCTURAS</b>. <br>
						<span class="fragment">Una estructura es una colección de campos.</span> <br>
						<span class="fragment">como se puede ver en este ejemplo:</span>

						</p>
						<pre class="fragment"><code>
		type Persona struct {
			Nombre string
			Apellido string
			Edad int
		}							
						</code></pre>
						
					</section>
					<section>
						<p>
							Para declarar una estructura se utiliza la palabra reservada <b>“type”</b>,  seguida del <b>NOMBRE</b> y el tipo <b>"struct”</b>.<br>
							<span class="fragment">Dentro de las llaves se establecera todos los campos que identificaran a nuestra estructura con su correspondiente tipo de datos a su lado</span>
						</p>
					</section>
					<section>
						<p>
							El <em>valor cero</em> de una estructura es una coleccion de <em>valores ceros</em> en sus campos. <br></p>
							<span class="fragment">...</span><span class="fragment">...</span><span class="fragment">...</span>
							<b class="fragment">QUE SIGNIFICA ESTO??</b> 
							<br>
							<span class="fragment">Que en el caso del ejemplo Persona, si lo inicializamos sin asignarle valores a sus campos al imprimir el objeto este mostraria <em>2 cadenas vacias y un 0</em>.</span>
						   
						
					</section>
					<section>
						<p>
							Para agregarle valores a los campos de una estructura se puede hacer de diferentes formas. <br>
							Se puede <b>crear el objeto</b> y luego <b>agregarle los valores</b> 
						</p>
						<pre><code>
	p := new(Persona)
	"o tambien"
	var p Persona
	p.Nombre = “fer”
	p.Apellido = “alvarez”
	p.Edad = 30
						   
						</code></pre>
						<span class="fragment">
							O se puede hacer de una forma directa:
						</span>
						<pre class="fragment"><code>
	persona := Persona{“fer”,”alvarez”,30}

						</code></pre>
					</section>
					<section>
						<p>
							Podemos acceder al valor de los campos de la estructura como en otros lenguajes con la notacion de puntos (Persona.Nombre).
						</p>
						<p class="fragment">
							Para crearle un metodo que lo pueda usar solo tu estructura como si fuese un metodo de una clase, se lo escribe de esta forma:
						</p>
						<pre class="fragment"><code>
	func (p *Persona) CumplirAnios(){
		p.Edad +=1
	}
						</code></pre>
	
					</section>
					<section>
						<p>
							Ya que las <b>estructuras</b> en GO no tienen herencia como en las clases de otros lenguajes, los desarrolladores pensaron una forma de hacerla mas sencilla. <br>
						</p>
						<p class="fragment">Esta seria pasarle la estructura a heredar por el campo donde se crea el objeto heredado.</p>
							<pre class="fragment"><code>
	type Caballero struct {
		Espada string
		Persona 
		}
							</code></pre>
						
					</section>
					<section>
						<p>
							Para crear un objeto se puede recurrir a la misma manera de antes.
						</p>
						<pre><code>
  	jefrey := new(Caballero)
  	jefrey.Espada="escalibur"
  	jefrey.Nombre="Sir"
  	jefrey.Apellido="Lancelot"
  	jefrey.Edad= 1800
						</code></pre>
						<p class="fragment">O la manera mas directa que esta vez es un poco diferente: </p>
						<pre class="fragment"><code>
	Lancelot := Caballero{"excalibur",
	Persona{"Sir","Lancelot",1800}}
						</code>
						</pre>
					</section>
					<section>
						<h3>Todo el codigo, que se dio como ejemplo para ejecutar.</h3>
						<iframe height="400px" width="100%" src="https://repl.it/@albertosanchez6/estructura?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
					</section>

				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
