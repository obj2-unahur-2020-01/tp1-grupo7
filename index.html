<!doctype html>
<html xmlns="http://www.w3.org/1999/html">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>*TP Grupo7*</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<p>
							<h3>Trabajo Práctico Grupal</h3>
						</p>
						<p class="fragment" data-fragment-index="0">Lenguaje a presentar: "GO"</p>
						<p class="fragment" data-fragment-index="1">
							Integrantes:
						</p>
						<p class="fragment" data-fragment-index="2">
							Alberto Leandro Sanchez<br>
							Hereñu Luis Marcelo <br>
							Yesica Belen Ramirez <br>
							Vallés Franco David <br>
							Rosa Alfonso
						</p>
					</section>
				</section>					
				<section id="fragments">
					<h2>Qué es GO?</h2>
					<p>Go es un lenguaje de programación...</p>
					<p><span class="fragment">...concurrente</span> <span class="fragment">y</span> <span class="fragment">compilado.</span></p>
						<p><span class= "fragment"> Inspirado en la sintaxis de C, que intenta ser dinámico como Python y con el rendimiento de C o C++.</span></p>
							<p><span class= "fragment"> Otras de sus características principales son que es imperativo, estructurado y orientado a objetos.</span></p>	
				</section>
				<section>
                    <section>
                        <h1> Un poco de historia sobre el lenguaje </h1>
                        <p> GO fue desarrollado por Google y sus diseñadores principales son: </p>
                        <p><span class="fragment"> Robert Griesemer, Rob Pike y Ken Thompson. </span></p>
                    </section>
					<section>
						<p> Go fue diseñado en Google, en el año 2007 para mejorar la productividad de programación de sus desarrolladores. </p>
                        <p><span class="fragment"> en una era de computadoras con procesadores de nucleos múltiples, conectadas a través de una network y bases de código fuente grandes. </span></p>
                        <p><span class="fragment"> Go fue anunciado públicamente en noviembre del 2009, y la versión 1.0 fue lanzada en marzo del 2012. </span></p>
					</section>
					<section>
						<p> Algunos de los motivos principales de los diseñadores para crear el lenguaje fueron: </p>
						<p> 1.-Las características que no les gustaban de C++. </p>
							<p><span class="fragment"> 2.-Corregir las critícas que tenían hacía otros lenguajes que se usaban en Google pero a su vez conservar las características útiles. Por ejemplo: </span></p>
						
							<p class="fragment" style="font-size:0.7em;"><span > - El tipado estático y la eficiencia del tiempo de ejecución, como el de C++.</span></p>
								<p class="fragment" style="font-size:0.7em;"><span > - La legibilidad y usabilidad de Python y JavaScript. 
									</span></p>
								<p class="fragment" style="font-size:0.7em;"><span > - Mejor desempeño de networking y multiprocesamiento. 
									</span></p>
						
					</section>	
				</section>
				
				<section>
					<h2>Asi se ve un programa basico en GO</h2>
					<iframe height="400px" width="100%" src="https://repl.it/@albertosanchez6/LoudAlarmedJavadoc?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
				</section>
				<section>
					<section>
						<h2>Variables</h2>
						<p>Las variables en Go se pueden declarar explicitamente o se puede incializar con un valor y estas no pueden cambiar de tipo en un futuro, para asegurar que cuando una funcion las llame sean del tipo correcto.</p>
					</section>
					<section>
						<p>Para declarar una variable se usa 'var'</p>
						<pre><code>var a string = "initial"</code></pre>
						<br>
						<p>Tambien se puede declarar multiples variables en una linea</p>
						<pre><code>var b, c int = 1, 2</code></pre>
					</section>
					<section>
						<p>Las variables pueden ser declaradas sin inicializarce, estas por default son de valor cero, por ejemplo:</p>
						<pre><code>var a int
var b string
var c float64
var d bool
	</code></pre>
						<p>el output de a seria "0", de b: "" , de c: "0" y de d: false </p>
						
					</section>
					<section>									
						<p>En Go existe la sintaxis ":=" que es una abreviatura para inicializar variables. Por ejemplo:</p>
						<pre><code>f := "short"</code></pre>
						<span>es igual a</span>
						<pre><code>var f string = "short"</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Funciones</h3>
						<p>Las funciones en Go proporcionan un código organizado y reutilizable para realizar un conjunto de acciones,
						simplifican el proceso de codificación, evitan la lógica redundante y hacen que el código sea más fácil de seguir. <br>
						Describiremos la declaración y la utilización de funciones, parametros, funciones y cierres literales, valores de retorno, valores de retorno nombrados y funciones variables.</p>
					</section>
					<section>
						<p>En el lenguaje Go es obligatorio el planteo de una función llamada main</p>
						<pre><code>package main 
import "fmt"

func saludar(nombre string, edad int) string {
    return fmt.Sprintf("Hola, mi nombre es %s y tengo %d años", nombre, edad)
}

func main() {
    fmt.Println(saludar("Orlando", 26))
}
						</code></pre>
						<p>Esta funcion es sumamente indispensable para ejecutar el programa</p>
					</section>
					<section>
						<p>Go tiene una serie de paquetes que proveen algunas funcionalidades básicas.</p>
						<p>Como se aprecia en el ejemplo, hemos empleado las funciones que nos provee el paquete "fmt".</p>
						<pre><code>package main 
import -"fmt" 

func main(){
	fmt.Print("Hola Mundo")
}
						</main></code></pre>
					</section>
					<section>
						<h3>Estructura de una funcion:</h3>
						<p>Una función comienza con la palabra clave func y seguida a esta su nombre, 
						puede tener parámetros, un valor o más de retorno y encerrada entre llaves le sigue su algoritmo (la llave de apertura debe ir en la mísma línea de la definición de la función):</p>
						<pre><code>func [nombre de la función] ([parámetros de la función]) [valor/es que retorna] {
	[altoritmo]
}
						</code></pre>
					</section>
					<section>
						<h3>Parametros</h3>
						<p>Una función puede declarar opcionalmente un conjunto de parámetros:</p>
						<pre><code>func SayHelloToMe(firstName, lastName string, age int) {
	fmt.Printf("Hello, %s %s!\n", firstName, lastName)
	fmt.Printf("You are %d", age)
}
						</code></pre>
						<p class="fragment">Observe que el tipo para firstName se omite porque es idéntica a lastName.</p>
					</section>
					<section>
						<h3>Funciones y cierres literales</h3>
						<p>En Go no solo existe la manera tradicinal de hacer funciones, si no que existen algunas un tanto peculiares.</p>
					</section>
					<section>
						<p>Una simple función literal, imprimiendo Hello! al stdout</p>
						<pre><code>package main

import "fmt"

func main() {
	func(){
		fmt.Println("Hello!")
	}()
}						
						</code></pre>
					</section>
					<section>
						<p>Una función literal, imprimiendo el argumento str a stdout:</p>
						<pre><code>func main() {
	func(str string) {
		fmt.Println(str)
	}("Hello!")
}
						</code></pre>
					</section>
					<section>
						<p>Una función literal, cerrando sobre la variable str :</p>
						<pre><code>import "fmt"

func main() {
	str := "Hello!"
	func() {
		fmt.Println(str)
	}()
}
						</code></pre>
					</section>
					<section>
						<p>Tambien es posible asignar una función literal a una variable:</p>
						<pre><code>package main

import (
	"fmt"
)

func main() {
	str := "Hello!"
	anon := func() {
		fmt.Println(str)
	}
	anon()
}
							</code></pre>
					</section>
					<section>
						<h3>Valores de retorno</h3>
						<p>Una función puede devolver uno o más valores al llamante:</p>
						<pre><code>func sum(a,b int)int{
	return a+b
}
						</code></pre>
						<pre><code>func AddAndMultiply(a, b int) (int, int) {
	return a+b, a*b
}
						</code></pre>
					</section>
					<section>
						<h3>Valores de retorno</h3>
						<p class="fragment">Dos cosas importantes deben ser notadas:</p>
						<p class= "fragment">1) Los paréntesis pueden omitirse para un único valor de retorno. <br>
							2) Cada declaración de return debe proporcionar un valor para todos los valores de retorno declarados.</p>
					</section>
					<section>
						<h3>Valores de retorno nombrados:</h3>
						<p>Los valores de retorno se pueden asignar a una variable local. 
						Una declaración de return vacía se puede usar para devolver sus valores actuales. 
						Esto se conoce como retorno "desnudo" .
						</p>
					</section>
					<section>
						<p>Ejemplo de una funcion con un unico valor a retornar: </p>
						<pre><code>func Inverse(v float32) (reciprocal float32) {
	if v == 0 {
		return
	}
	reciprocal = 1 / v
	return
}
						</code></pre>
						<p class="fragment"> Las declaraciones de devoluciones desnudas se deben 
						usar solo en funciones cortas, ya que dañan la legibilidad en funciones más largas</p>
					</section>
					<section>
						<p>Ejemplo de una funcion con multiples valores retornados:</p>
						<pre><code>func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
						</code></pre>
						<p class="fragment">Dos cosas importantes deben ser notadas:</p>
						<p class="fragment">1) Los paréntesis alrededor de los valores de retorno son obligatorios. <br>
						2) Siempre se debe proporcionar una declaración de return vacía.</p>
					</section>
					<section>
						<h3>Funciones Variables</h3>
						<p>Se puede llamar a una función variad con cualquier número de argumentos finales.</p>
						<pre><code>package main

import "fmt"

func variadic(strs ...string) {
		// strs is a slice of string
		for i, str := range strs {
			fmt.Printf("%d: %s\n", i, str)
		}
}

func main() {
		variadic("Hello", "Goodbye")
		variadic("Str1", "Str2", "Str3")
}
							</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Condicionales</h3>
						<p> Las sentencias condicionales en GO nos permiten controlar la ejecución de código en nuestro algoritmo, dependiendo del resultado de la evaluación de la condición que se define en la estructura del condicional.</p>
					</section>
					<section>
						<p> hay diferentes tipos de sentencias condicionales: </p>
						<p> sentencia IF</p>
						<p> sentencia IF-ELSE</p>
						<p> sentencia ELSE IF</p>
						<p> sentencia SWITCH</p>
						<p> sentencia SELECT</p>
					</section>
					<section>
						<h4> Sentencia IF</h4>
						<p>	La sentencia if se utiliza para verificar la veracidad de una expresión, y de ser verdadera se ejecutará el código destinado para cuando la condición se cumpliera</p>
					</section>
					<section>
						<p> Ejemplo: Tenemos una variable “número” definida con valor de entero 5 y tenemos una sentencia IF con la condición a evaluar de que si la variable “número” es menor que 9 diera verdadera, debe ejecutarse la llamada al println de fmt, el cual imprimirá en pantalla “el número es menor a 9”.</p>
						<pre><code data-trim data-noescape>
							var numero int = 5
							if  numero<9{
							fmt.Println(“el numero es menor a 9”)
							}
						</code></pre>
					</section>
					<section>
						<p> Pero esto es limitado, ¿Qué sucede si quiero ejecutar una parte del código cuando no se cumpla la condición?</p>
						<p><span class="fragment"> para ello utilizaremos la sentencia IF-ELSE. </span></p>
					</section>
					<section>
						<h5> Sentencia IF-ELSE</h5>
						<p> Ah la sentencia IF , se le agrega otra rama de ejecución llamada ELSE, cuando la condición establecida en la sentencia IF no se cumpla, se ejecutará el código definido en la rama else.	</p>
						<pre><code data-trim data-noescape>
							var numero int = 5
							if  numero<9{
								fmt.Println(“el numero es menor a 9”)
							}else{
								fmt.Println(“el numero es mayor a 9”)
							}
						</code></pre>
					</section>
					<section>
						<h6> PREGUNTA</h6>
						<p> Qué sucede si queres trabajar con múltiples condiciones en cadena, para que se evalúen de a una?</p>
						<br>
						<p><span class="fragment"> RESPUESTA: ELSE IF. </span></p>
					</section>
					<section>
						<h7>Sentencia ELSE IF</h7>
						<p>La sentencia ELSE IF nos permite encadenar condiciones para que se evalúen en el instante en que la condición anterior dio falsa.</p>
						<pre><code data-trim data-noescape>
							var numero int = 5
							if  numero<9{
								fmt.Println(“el numero es menor a 9”)
							}
							else if numero == 5{
								fmt.Println(“el numero es igual a 5”)
							}
							else{
								fmt.Println(“el numero es mayor a 9”)
							}
						</code></pre>
						<p>	Con esto finaliza las sentencias relacionadas al IF.</p>
					</section>
					<section>
						<h8>Sentencia SWITCH</h8>
						<p>Esta sentencia nos permite evaluar una variable contra una lista de valores conocidos como case (casos en ingles).</p>
						<p> En GO los switch pueden ser de dos tipos</p>
						<p><span class="fragment">
							EXPRESIÓN: Los case contienen expresiones que son comparadas con el valor de la variable a evaluar.
						</span></p>
						<br>
						<p><span class="fragment">
							TIPO: Los case contienen un tipo de dato que es comparado con el tipo de dato de la variable a evaluar.
						</span></p>
					</section>
					<section>
						<h9>Switch de expresiones:</h9>
						<p>Reglas que aplican para este tipo de switch:</p>
						<p> •Si no pasa una expresión, el valor por defecto es true.</p>
						<p>	•No hay límite de case siempre y cuando cada case esté seguido de al menos un valor contra el cual comparar y dos puntos.</p>
						<p>	•Si se usa una expresión constante para un case, debe de ser del mismo tipo que el valor a evaluar, y debe de ser una constante o literal.</p>
					</section>
					<section>
						<p>	•Cuando la variable a evaluar es igual a un case, el código después de los dos puntos (“ : “) se ejecuta. No se utiliza break para terminar el case.</p>
						<p>	•Puede haber un case por default (defecto) para ejecutarse cuando no se cumple ningún case. El case default debe ir al final y no necesita break.</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code data-trim data-noescape>
							func main() {
								/*variable local de tipo entero*/
								var hora int = 10
								/*Se pasa hora como variable de prueba*/
								switch hora{
								/*Si hora coincide con alguna de las literales especificadas*/
									case 1, 2, 3, 4: fmt.Println("Aún es temprano")
									case 5, 6, 7: fmt.Println("Está atardeciendo")
									case 8: fmt.Println("Acaba de oscurecer")
									case 9, 10, 11: fmt.Println("Ya es tarde")
									default: fmt.Println("Es demasiado tarde")
								}
							}
						</code></pre>
					</section>
					<section>
						<h10> Switch de tipo</h10>
						<p>	Reglas que aplican para este tipo de switch:</p>
						<p>	•La expresión usada en una sentencia debe de ser una variable o una interface de tipo</p>
						<p>	•No hay límites para la cantidad de case en el switch.</p>
						<p>	•El tipo de dato para un case debe ser el mismo tipo que la variable a evaluar.</p>
						<p>	•Cuando la variable a evaluar es igual a un case, se ejecuta dicho case y los demás no son verificados. No es necesario un break.</p>
					</section>
					<section>
						<p> •Puede haber un case default, para ejecutarse cuando no se cumple ningún case. el case default debe ir al final y no utiliza break</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code data-trim data-noescape>
							func main() {
								/*variable interface sin tipo asignado*/
								var x interface{}
								switch x.(type){ /*Retorna el tipo de x*/
									/*Casos*/
									case nil: fmt.Println("Es una variable tipo nil")
									case int: fmt.Println("Es una variable tipo int")
									case float64: fmt.Println("Es una variable tipo float64")
									case int64: fmt.Println("Es una variable tipo int64")
									default: fmt.Println("No es ninguno de los tipos anteriores")
								}
							}
						</code></pre>
					</section>
					<section>
						<h11>Sentencia SELECT CASE</h11>
						<p>La sentencia select case, permite ejecutar una de entre varias acciones en función del valor de una expresión.</p>
					</section>
					<section>
						<p>	como funciona?</p>
						<p>	1.Se evalúa la expresión, dando como resultado un número.</p>
						<p> 2.Luego, se recorren los case, dentro de la estructura buscando que el número coincida con uno de los valores.</p>
						<p> 3.Es necesario que coincidan todos sus valores.</p>

					</section>
					<section>
						<p> 4.Cuando se encuentra la primera coincidencia, se ejecuta el bloque de sentencias correspondiente y se sale de la estructura select case.</p>
						<p> 5.Si no se encuentra ninguna coincidencia con ningún valor, se ejecuta el bloque de sentencias de la selección case else.</p>
					</section>
					<section>
						<p> EJEMPLO</p>
						<pre><code data-trim data-noescape>
							Select (Expresion)
								Case Valor1
									(Bloque de sentencias 1)
								Case Valor2
									(Bloque de sentencias 2)
								Case Valor n
									(Bloque de sentencias n)
								Case Else
									(Bloque de sentencias "Else")
								End Select
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Clases/Estructuras</h3>
					</section>
					<section>
						<p>
							En <b> GO</b> no existen las clases como tal, en este lenguaje se pueden hacer <b>ESTRUCTURAS</b>. <br>
						<span class="fragment">Una estructura es una colección de campos.</span> <br>
						<span class="fragment">como se puede ver en este ejemplo:</span>

						</p>
						<pre class="fragment"><code data-trim data-noescape>
		type Persona struct {
			Nombre string
			Apellido string
			Edad int
		}							
						</code></pre>
						
					</section>
					<section>
						<p>
							Para declarar una estructura se utiliza la palabra reservada <b>“type”</b>,  seguida del <b>NOMBRE</b> y el tipo <b>"struct”</b>.<br>
							<span class="fragment">Dentro de las llaves se establecera todos los campos que identificaran a nuestra estructura con su correspondiente tipo de datos a su lado</span>
						</p>
					</section>
					<section>
						<p>
							El <em>valor cero</em> de una estructura es una coleccion de <em>valores ceros</em> en sus campos. <br></p>
							<span class="fragment">...</span><span class="fragment">...</span><span class="fragment">...</span>
							<b class="fragment">QUE SIGNIFICA ESTO??</b> 
							<br>
							<span class="fragment">Que en el caso del ejemplo Persona, si lo inicializamos sin asignarle valores a sus campos al imprimir el objeto este mostraria <em>2 cadenas vacias y un 0</em>.</span>
						   
						
					</section>
					<section>
						<p>
							Para agregarle valores a los campos de una estructura se puede hacer de diferentes formas. <br>
							Se puede <b>crear el objeto</b> y luego <b>agregarle los valores</b> 
						</p>
						<pre><code>
	p := new(Persona)
	"o tambien"
	var p Persona
	p.Nombre = “fer”
	p.Apellido = “alvarez”
	p.Edad = 30
						   
						</code></pre>
						<span class="fragment">
							O se puede hacer de una forma directa:
						</span>
						<pre class="fragment"><code>
	persona := Persona{“fer”,”alvarez”,30}

						</code></pre>
					</section>
					<section>
						<p>
							Podemos acceder al valor de los campos de la estructura como en otros lenguajes con la notacion de puntos (Persona.Nombre).
						</p>
						<p class="fragment">
							Para crearle un metodo que lo pueda usar solo tu estructura como si fuese un metodo de una clase, se lo escribe de esta forma:
						</p>
						<pre class="fragment"><code>
	func (p *Persona) CumplirAnios(){
		p.Edad +=1
	}
						</code></pre>
	
					</section>
					<section>
						<p>
							Ya que las <b>estructuras</b> en GO no tienen herencia como en las clases de otros lenguajes, los desarrolladores pensaron una forma de hacerla mas sencilla. <br>
						</p>
						<p class="fragment">Esta seria pasarle la estructura a heredar por el campo donde se crea el objeto heredado.</p>
							<pre class="fragment"><code>
	type Caballero struct {
		Espada string
		Persona 
		}
							</code></pre>
						
					</section>
					<section>
						<p>
							Para crear un objeto se puede recurrir a la misma manera de antes.
						</p>
						<pre><code>
  	jefrey := new(Caballero)
  	jefrey.Espada="escalibur"
  	jefrey.Nombre="Sir"
  	jefrey.Apellido="Lancelot"
  	jefrey.Edad= 1800
						</code></pre>
						<p class="fragment">O la manera mas directa que esta vez es un poco diferente: </p>
						<pre class="fragment"><code>
	Lancelot := Caballero{"excalibur",
	Persona{"Sir","Lancelot",1800}}
						</code>
						</pre>
					</section>
					<section>
						<h3>Todo el codigo, que se dio como ejemplo para ejecutar.</h3>
						<iframe height="400px" width="100%" src="https://repl.it/@albertosanchez6/estructura?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
					</section>

				</section>
				<section>
					<section>
						<h3>Bucles</h3>
						<div class="fragment">
							<p>Un bucle es una estructura propia de un lenguaje de programación, que permite ejecutar un bloque de código repetidamente.</p>
						</div>
						<div class="fragment">
							<p>En el caso de <b>Go</b>, cuenta únicamente con la estructura <em>for</em>, careciendo de otras conocidas como <em>while</em> o <em>do while</em> presentes en otros lenguajes como C.</p>
						</div>
					</section>
					<section>
						<p>Existen distintas formas para usar la sentencia <em>for</em> en Go:</p>
						<div class="fragment">
							<p>•	Sentencia for clásica.</p>
						</div>
						<div class="fragment">
							<p>•	Sentencia for como while.</p>
						</div>
						<div class="fragment">
							<p>•	Sentencia for como bucle infinito.</p>
						</div>
						<div class="fragment">
							<p>•	Sentencia for en un rango.</p>
						</div>
						<div class="fragment">
							Analicemos caso por caso.
						</div>
					</section>
					<section>
						<h3>Sentencia for clásica</h3>
						<div class="fragment">
							<p>Se trata de la estructura habitual de for en la mayoría de los lenguajes de programación, con la única diferencia de que no hay paréntesis que rodeen los tres componentes de for y las llaves {} siempre son necesarias.</p>
						</div>
					</section>
					<section>
						<h3>Sentencia for clásica</h3>
						<h6>Estructura genérica</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								for [Inicialización;Condición;Incremento]{
									//Bloque de código
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h4>Sentencia for clásica</h4>
						<h6>Referencias</h6>
						<div class="fragment">
							<p><b>Inicialización</b>: Se ejecuta antes de la primera iteración. En general, se trata de la declaración de una variable corta que sólo existe dentro del <em>for</em>.</p>
						</div>
						<div class="fragment">
							<p><b>Condición</b>: Se trata de una expresión booleana que se evalúa antes de cada iteración.</p>
						</div>
						<div class="fragment">
							<p><b>Incremento</b>: Se ejecutará después de cada iteración exitosa del bucle. Después de que se ejecute el incremento, se volverá a verificar la condición.</p>
						</div>
					</section>
					<section>
						<h4>Sentencia for clásica</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									sum := 0
									for i := 0; i < 10; i++ {
										sum += i//suma los números de 0 al 9
									}
									fmt.Println(sum)
								}
								//Salida: 45
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Sentencia for como while</h3>
						<div class="fragment">
							<p>Debido a que las instancias de inicialización y de incremento no son obligatorias en <b>Go</b>, <em>for</em> puede usarse de forma similar al <em>while</em> propio de otros lenguajes de programación.</p>
						</div>
					</section>
					<section>
						<h3>Sentencia for como while</h3>
						<h6>Estructura genérica</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								for [Condición]{
									//Bloque de código
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h4>Sentencia for como while</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									i:= 0
									for i < 5 {
										i += 2//suma de a 2 hasta que supera al 5
									}
									fmt.Println(i)
								}
								//Salida: 6
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Sentencia for como bucle infinito</h3>
						<div class="fragment">
							<p>Existe, también, la posibilidad de omitir la condición de bucle. Cuando no se escribe la condición, significa que es verdadera y el bucle se vuelve infinito.</p>
						</div>
					</section>
					<section>
						<h4>Sentencia for como bucle infinito</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main

								func main() {
									for {
									}
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Sentencia for en un rango</h3>
						<div class="fragment">
							<p>Con una aplicación similar a un <em>for-each</em>, la función <em>for-range</em> permite iterar dentro de array, slice, map, string o channel.</p>
						</div>
					</section>
					<section>
						<h3>Sentencia for en un rango</h3>
						<h6>Estructura genérica</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								for [Índice,Valor := range Estructura a Recorrer]{
									//Bloque de código
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h4>Sentencia for en un rango</h4>
						<h6>Referencias</h6>
						<div class="fragment">
							<p><b>Índice</b>: es la posición o clave del valor al que se accede. Puede omitirse reemplazándolo por un “_”.</p>
						</div>
						<div class="fragment">
							<p><b>Valor</b>: es el valor real que se obtiene en cada iteración. En general, esta segunda variable es opcional, pudiendo reemplazarse por un “_” o simplemente omitiéndolo. Si lo que se recorre es un channel, esta variable no posee un valor.</p>
						</div>
					</section>
					<section>
						<h4>Sentencia for en un rango</h4>
						<h6>Referencias</h6>
						<div class="fragment">
							<p><b>Estructura a Recorrer</b>: contiene la estructura de datos a cuyos valores se accederá en el bucle. Si es nulo, el número de iteraciones es 0.</p>
						</div>
					</section>
					<section>
						<h4>Sentencia for en un rango</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									numeros := []int{5,7,13,8}
									for indice, numero := range numeros {
										fmt.Println("En la posición ",indice," está el ",numero)
									}// recorre un slice de números
								}
								//Salida:
								//En la posición 0 está el 5
								//En la posición 1 está el 7
								//En la posición 2 está el 13
								//En la posición 3 está el 8
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Declaraciones de control de bucles</h3>
						<div class="fragment">
							<p>Las declaraciones de control de bucles modifican la ejecución normal del <em>for</em>.</p>
						</div>
					</section>
					<section>
						<p>En <b>Go</b> existen 3 declaraciones de control:</p>
						<div class="fragment">
							<p>•	Break.</p>
						</div>
						<div class="fragment">
							<p>•	Continue.</p>
						</div>
						<div class="fragment">
							<p>•	Goto.</p>
						</div>
						<div class="fragment">
							Estudiemos cada uno.
						</div>
					</section>
					<section>
						<h3>Break</h3>
						<div class="fragment">
							<p>Break se usa para terminar el ciclo <em>for</em> abruptamente antes de que finalice su ejecución normal y mover el control a la línea de código después del ciclo.</p>
						</div>
					</section>
					<section>
						<h4>Break</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									for i:=0 ; i < 10; i++ {//Debería imprimir hasta el 9
										fmt.Printf("Valor de i: %d", i)
										if i == 3{
											break// pero el break lo termina en el 3
										}
										fmt.Printf("\n")
									}
								}
								//Salida:
								//Valor de i: 0
								//Valor de i: 1
								//Valor de i: 2
								//Valor de i: 3
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Break</h3>
						<div class="fragment">
							<p>Es importante aclarar que en caso de anidación de <em>for</em>, break sólo termina el ciclo del que forma parte.</p>
						</div>
					</section>
					<section>
						<h4>Break</h4>
						<h6>Ejemplo anidación</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									for i := 0; i < 3; i++ {
										for j := 1; j < 4; j++ {
											fmt.Printf("i = %d , j = %d\n", i, j)
											if i == j {
												break
											}
										}
									}
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h4>Break</h4>
						<h6>Ejemplo anidación</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								//Salida:
								//i=0, j=1
								//i=0, j=2
								//i=0, j=3
								//i=1, j=1
								//i=2, j=1
								//i=2, j=2
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Break</h3>
						<div class="fragment">
							<p>Por lo tanto, si lo que se desea es terminar la ejecución del bloque completo, puede usarse una label. Volviendo al ejemplo anterior.</p>
						</div>
					</section>
					<section>
						<h4>Break</h4>
						<h6>Ejemplo anidación con label</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
								outer:
									for i := 0; i < 3; i++ {
										for j := 1; j < 4; j++ {
											fmt.Printf("i = %d , j = %d\n", i, j)
											if i == j {
												break outer
											}
										}
									}
								}
							</code></pre>
						</div>
					</section>
					<section>
						<h4>Break</h4>
						<h6>Ejemplo anidación con label</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								//Salida:
								//i=0, j=1
								//i=0, j=2
								//i=0, j=3
								//i=1, j=1
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Continue</h3>
						<div class="fragment">
							<p>Continue se usa para omitir la iteración actual del ciclo <em>for</em>. Todo el código presente después de continue no se ejecutará para la iteración actual y pasará a la siguiente.</p>
						</div>
					</section>
					<section>
						<h4>Continue</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									for i := 1; i <= 10; i++ {
										if i%2 == 0 {
											continue
										}
										fmt.Printf("%d ", i)
									}// imprime los números impares del 1 al 10
								}
								//Salida: 1 3 5 7 9
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Goto</h3>
						<div class="fragment">
							<p>Una sentencia goto permite el “salto” hasta una label dentro de la misma función. Si se utiliza goto, el flujo del programa continúa de forma estructurada a partir de la label que se especificó.</p>
						</div>
						<div class="fragment">
							<p>Su uso es generalmente desaconsejado debido a que dificulta su seguimiento. Cualquier programa que use un goto puede reescribirse usando alguna otra construcción.</p>
						</div>
					</section>
					<section>
						<h4>Goto</h4>
						<h6>Ejemplo</h6>
						<div class="fragment">
							<pre><code data-trim data-noescape>
								package main
								import "fmt"

								func main() {
									var a int = 10
									LOOP: for a < 15 {
										if a == 12 {
											a = a + 1
											goto LOOP
										}
										fmt.Printf("Valor de a: %d\n", a)
										a++
									}
								}
								//Salida:
								//Valor de a: 10
								//Valor de a: 11
								//Valor de a: 13
								//Valor de a: 14

							</code></pre>
						</div>
					</section>
				</section>
				<section>
					<h2>Arreglos en GO</h2>
					<div class="fragment">
						<p>En Go, un <em>Array</em> es una secuencia enumerada de elementos, de un tamaño específico inmutable.</p>
					</div>
					<div class="fragment">
						<p>La sintaxis para declarar un arreglo sería; <em>var := x [l]T{n}</em>; [l] simboliza el tamaño del arreglo, T el tipo del dato que contiene y {n} el contenido.</p>
					</div>
					<div class="fragment">
						<p>También es posible declarar un arreglo vacío y agregar valores en cada indice individualmente.</p>
					</div>	
				</section>
				<section>
					<h6>Por ejemplo:</h6>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main
							import "fmt"

							func main() {
								var a [5]int
								fmt.Println("emp:", a)
								a[4] = 100
								fmt.Println("set:", a)
								fmt.Println("get:", a[4])
								fmt.Println("len:", len(a))
								b := [5]int{1, 2, 3, 4, 5}
								fmt.Println("dcl:", b)
							}
							/*outputs:
							emp: [0 0 0 0 0]
							set: [0 0 0 0 100]
							get: 100
							len: 5
							dcl: [1 2 3 4 5]*/
						</code></pre>
					</div>
					<div class="fragment">
						<p>Acá estamos creando un array que va a contener exactamente 5 ints. El tipo de datos y el tamaño, son ámbos parte de el tipo del array.</p>
					</div>
				</section>
				<section>
					<h4>Características principales de los arreglos en GO:</h4>
					<div class="fragment">
						<p>1.- Por defecto un array vacío, de ints contiene 0s y un array de strings contiene espacios en blanco. Los arrays siempre arrancan desde el indice 0 en adelante.</p>
					</div>	
					<div class="fragment">
						<p>2.- Podemos setear un valor en un indice concreto usando; <em> arreglo[index] = valor</em>; y obtener un valor usando;<em> arreglo[index]</em>. La función primitiva <em>len</em> retorna el tamaño del arreglo.</p> 
					</div>
				</section>
				<section>
					<div class="fragment">
						<p>3.- En un array, la elipsis <em>(...)</em> puede ser usada en donde se define el tamaño del array, y su tamaño va ser determinado por la cantidad de datos que contiene inicialmente.</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main 
							import "fmt"

							func main() {
								abecedario:= [...]string{"A", "B", "C", "D", "E"} 
								fmt.Println("Elementos del arreglo: ", abecedario)
								fmt.Println("Tamaño del arreglo: ", len(abecedario)) 
							}
							/*outputs:
							Elementos del arreglo:  [A B C D E]
							Tamaño del arreglo: 5*/
						</code></pre>
					</div>
				</section>
				<section>	
					<div class="fragment">
						<p>4.- Es posible iterar un arreglo sobre el range de los elementos que contiene el arreglo.</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main
							import "fmt"
							
							func main() {
								array:=[...]int{29,79,49,29}
								for x:=0; x < len(array); x++ { 
									fmt.Printf("%d\n", array[x]) 
								}
							}
							/*outputs:
							29
							79
							49
							29*/
						</code></pre>
					</div>	
				</section>
				<section>
					<div class="fragment">
						<p>5.- En Go, un array es un tipo de valor, no un tipo de referencia. Cuando un array es asignado a una var nueva, los cambios realizados a la var nueva no afectan el array original.</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main							
							import "fmt"
							
							func main() {
								array:=[...]int{10,20,30,40}
								fmt.Printf("Arreglo original(antes): ", array) 
								newArray:=array
								fmt.Printf("Arreglo nuevo(antes): ", newArray)
								newArray[0]=50
								fmt.Printf("Arreglo nuevo(después): ", newArray)
								fmt.Printf("Arreglo original(después): ", array)
							}
							/*outputs:
							Arreglo original(antes): [10 20 30 40]
							Arreglo nuevo(antes): [10 20 30 40]
							Arreglo nuevo(después): [50 20 30 40]
							Arreglo original(después): [10 20 30 40]*/
						</code></pre>
					</div>
				</section>	
				<section>	
					<div class="fragment">
						<p>6.- En un array, sí el tipo del dato del array es comparable, entonces el tipo del array también es comparable. Es posible comparar directamente 2 arrays usando el operador de igualdad (==).</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main			
							import "fmt"
							
							func main() {
								arr1:=[3]int{9,7,6}
								arr2:=[...]int{9,7,6}
								arr3:=[3]int{9,5,3}
								fmt.Println(arr1==arr2) 
								fmt.Println(arr2==arr3) 
								fmt.Println(arr1==arr3)
							}
							/*outputs:
							true
							false
							false*/
						</code></pre>
					</div>					
				</section>
				<section>
					<h6>Limitaciones de los arreglos en GO:</h6>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main						
							import "fmt"
							
							func main() {
								var twoD [2][3]int
								for i := 0; i < 2; i++ {
									for j := 0; j < 3; j++ {
										twoD[i][j] = i + j
									}
								}
								fmt.Println("2d: ", twoD)
							}
							//2d: [[0 1 2] [1 2 3]]
						</code></pre>
					</div>
					<div class="fragment">
						<p>Los tipos de los arrays son unidimensionales, es posible componer tipos para crear estructuras de datos multidimensionales.</p>
					</div>
					<div class="fragment">
						<p>Los <em>Slices</em>, son una abstracción de los arrays y no tienen el mismo problema.</p>
					</div>	
				</section>
				<section>
					<h4>Diferencias principales entre Arrays y Slices en GO:</h4>
					<div class="fragment">
						<p>1.- Los Slices son de tamaño dinámico, la primer posición del indice en un Slice es siempre 0 y la última sería tamaño del Slice – 1. Si un Slice es creado sin inputs su tipo es <em>nil</em>.</p>
					</div>
					<div class="fragment">
						<p>2.- Tienen una función primitiva que permite definirlos; <em>make([]tipo,tamaño,capacidad)</em>; tipo representa el tipo de los datos que contiene, tamaño es el total de los elementos que contiene y capacidad el tamaño máximo hasta el que se puede extender.</p>
					</div>
				</section>	
				<section>	
					<div class="fragment">
						<p>3.- Son un tipo de referencia por lo tanto, sí pueden ser afectados por cambios realizados a una variable nueva que contiene el Slice original.</p>
					</div>
					<div class="fragment">
						<p>4.- No pueden ser comparados de la misma forma que un Array común, a los Slice sólo se les puede preguntar un no lógico, por ejemplo: Sí es o no es nil.</p> 
					</div>
				</section>	
				<section>	
					<div class="fragment">
						<p>5.- También cuentan con un operador especial; <em>array[low:high]</em>; lo que genera un Slice desde low hasta high-1, apartir de un Array u otro Slice.</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main							
							import "fmt"
							
							func main() {
								arr [6]int{1,2,3,4,5,6}
								slice arr[2:5]
								fmt.Printf("Slice: ",slice)
							}
							/*output:
							Slice: [2 3 4]*/
						</code></pre>
					</div>
				</section>
				<section>
					<h4>Características principales de los Slices en GO:</h4>
					<div class="fragment">
						<p>1.- Comparten las funciones de set, get y len con los Arrays.</p>
					</div>
					<div class="fragment">
						<p>2.- Tienen una función de; <em>append(slice,dato)</em>; que retorna el Slice original recibido por parámetro modificado, conteniendo uno o más (cada dato es separado por una coma) datos nuevos.</p>
					</div>
					<div class="fragment">
						<p>3.- Tienen una función que permite copiarlos; <em>copy(slice nuevo,slice original)</em>; que retorna un Slice nuevo que es la copia del original, sin modificar el Slice original.</p>
					</div>
				</section>
				<section>
					<div class="fragment">
						<p>4.- Los Slices pueden ser combinados en estructuras de datos multidimensionales. El tamaño de los Slices internos puede variar, al contrario de los Arrays multidimensionales.</p>
					</div>
					<div class="fragment">
						<pre><code data-trim data-noescape>
							package main
							import "fmt"
							
							func main() {
								twoD := make([][]int, 3)
								for i := 0; i < 3; i++ {
									innerLen := i + 1
									twoD[i] = make([]int, innerLen)
									for j := 0; j < innerLen; j++ {
										twoD[i][j] = i + j
									}
								}
								fmt.Println("2d: ", twoD)
							}
							/*output:
							2d:  [[0] [1 2] [2 3 4]]*/
						</code></pre>
					</div>
				</section>	
			</div>
		</div>			
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
